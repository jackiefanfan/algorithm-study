class Solution:
    def maxProfit(self, k, prices):

        n = len(prices)
        
        # many transactions (greedy solution)
        if k >= n/2:
            return sum([i-j for i, j in zip(prices[1:], prices[:-1]) if i - j > 0])
        
        # dp[i][j] is the maximum profit you can get by using i transactions and the first j prices
        dp = [[0] * n for _ in range(k+1)]

        for i in range(1, k+1):
            for j in range(1, n):
                maxVal = 0
                for m in range(j):
                    maxVal = max(maxVal, prices[j] - prices[m] + dp[i-1][m])
                dp[i][j] = max(dp[i][j-1], maxVal)
        
        return dp[-1][-1]
        
    # solution 2
	#  complexity O(k*n)
    def maxProfit(self, k, prices):

        n = len(prices)
        if k >= n/2:
            return sum([i-j for i, j in zip(prices[1:], prices[:-1]) if i - j > 0])
        
        dp = [[0] * n for _ in range(k+1)]
        for i in range(1, k+1):
            # maxDiff can be considered as the maximum left in the pocket after you buy the stock
            # but haven't sold it
            maxDiff = -prices[0]
            for j in range(1, n):
                # this means no transations, or sell the stock with prices[j]
                dp[i][j] = max(dp[i][j-1], maxDiff + prices[j])
                # maxDiff will iterate dp[i-1][m] - prices[m] m=[0...j]
                # to look for a date to buy the stock with maximum profit
                maxDiff = max(maxDiff, dp[i-1][j] - prices[j])
             
        return dp[-1][-1]
